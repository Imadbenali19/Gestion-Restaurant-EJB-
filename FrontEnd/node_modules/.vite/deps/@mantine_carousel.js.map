{
  "version": 3,
  "sources": ["../../embla-carousel/src/components/utils.ts", "../../embla-carousel/src/components/Alignment.ts", "../../embla-carousel/src/components/Animation.ts", "../../embla-carousel/src/components/Axis.ts", "../../embla-carousel/src/components/Limit.ts", "../../embla-carousel/src/components/Counter.ts", "../../embla-carousel/src/components/Direction.ts", "../../embla-carousel/src/components/EventStore.ts", "../../embla-carousel/src/components/Vector1d.ts", "../../embla-carousel/src/components/DragHandler.ts", "../../embla-carousel/src/components/DragTracker.ts", "../../embla-carousel/src/components/PercentOfView.ts", "../../embla-carousel/src/components/ScrollBody.ts", "../../embla-carousel/src/components/ScrollBounds.ts", "../../embla-carousel/src/components/ScrollContain.ts", "../../embla-carousel/src/components/ScrollLimit.ts", "../../embla-carousel/src/components/ScrollLooper.ts", "../../embla-carousel/src/components/ScrollProgress.ts", "../../embla-carousel/src/components/ScrollSnaps.ts", "../../embla-carousel/src/components/ScrollTarget.ts", "../../embla-carousel/src/components/ScrollTo.ts", "../../embla-carousel/src/components/Translate.ts", "../../embla-carousel/src/components/SlideLooper.ts", "../../embla-carousel/src/components/SlidesInView.ts", "../../embla-carousel/src/components/SlideSizes.ts", "../../embla-carousel/src/components/SlidesToScroll.ts", "../../embla-carousel/src/components/Engine.ts", "../../embla-carousel/src/components/EventHandler.ts", "../../embla-carousel/src/components/Options.ts", "../../embla-carousel/src/components/OptionsHandler.ts", "../../embla-carousel/src/components/PluginsHandler.ts", "../../embla-carousel/src/components/index.ts", "../../embla-carousel-react/src/components/utils.ts", "../../embla-carousel-react/src/components/index.ts", "../../@mantine/carousel/src/Carousel.errors.ts", "../../@mantine/carousel/src/Carousel.context.ts", "../../@mantine/carousel/src/CarouselSlide/CarouselSlide.styles.ts", "../../@mantine/carousel/src/CarouselSlide/CarouselSlide.tsx", "../../@mantine/carousel/src/get-chevron-rotation.ts", "../../@mantine/carousel/src/Carousel.styles.ts", "../../@mantine/carousel/src/Carousel.tsx", "../../@mantine/carousel/src/use-animation-offset-effect.ts"],
  "sourcesContent": ["export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n}\n\nexport function isNumber(subject: unknown): subject is number {\n  return typeof subject === 'number'\n}\n\nexport function isObject(subject: unknown): subject is Record<string, unknown> {\n  return Object.prototype.toString.call(subject) === '[object Object]'\n}\n\nexport function isArray(subject: unknown): subject is Record<number, unknown> {\n  return Array.isArray(subject)\n}\n\nexport function isRecord(\n  subject: unknown,\n): subject is Record<string | number, unknown> {\n  return isObject(subject) || isArray(subject)\n}\n\nexport function mathAbs(n: number): number {\n  return Math.abs(n)\n}\n\nexport function mathSign(n: number): number {\n  return !n ? 0 : n / mathAbs(n)\n}\n\nexport function deltaAbs(valueB: number, valueA: number): number {\n  return mathAbs(valueB - valueA)\n}\n\nexport function factorAbs(valueB: number, valueA: number): number {\n  if (valueB === 0 || valueA === 0) return 0\n  if (mathAbs(valueB) <= mathAbs(valueA)) return 0\n  const diff = deltaAbs(mathAbs(valueB), mathAbs(valueA))\n  return mathAbs(diff / valueB)\n}\n\nexport function roundToDecimals(decimalPoints: number): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number): number => Math.round(n * pow) / pow\n}\n\nexport function arrayKeys<Type>(array: Type[]): number[] {\n  return objectKeys(array).map(Number)\n}\n\nexport function arrayLast<Type>(array: Type[]): Type {\n  return array[arrayLastIndex(array)]\n}\n\nexport function arrayLastIndex<Type>(array: Type[]): number {\n  return Math.max(0, array.length - 1)\n}\n\nexport function objectKeys<Type>(object: Type): string[] {\n  return Object.keys(object)\n}\n\nexport function objectsMergeDeep(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): Record<string, unknown> {\n  return [objectA, objectB].reduce((mergedObjects, currentObject) => {\n    objectKeys(currentObject).forEach((key) => {\n      const valueA = mergedObjects[key]\n      const valueB = currentObject[key]\n      const areObjects = isObject(valueA) && isObject(valueB)\n\n      mergedObjects[key] = areObjects\n        ? objectsMergeDeep(valueA, valueB)\n        : valueB\n    })\n    return mergedObjects\n  }, {})\n}\n\nexport function objectsAreEqual(\n  objectA: Record<string, unknown>,\n  objectB: Record<string, unknown>,\n): boolean {\n  const objectAKeys = objectKeys(objectA)\n  const objectBKeys = objectKeys(objectB)\n\n  if (objectAKeys.length !== objectBKeys.length) return false\n\n  return objectAKeys.every((key) => {\n    const valueA = objectA[key]\n    const valueB = objectB[key]\n    if (typeof valueA === 'function') return `${valueA}` === `${valueB}`\n    if (!isRecord(valueA) || !isRecord(valueB)) return valueA === valueB\n    return objectsAreEqual(valueA, valueB)\n  })\n}\n", "import { isNumber } from './utils'\n\nexport type AlignmentOptionType = 'start' | 'center' | 'end' | number\n\nexport type AlignmentType = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(\n  align: AlignmentOptionType,\n  viewSize: number,\n): AlignmentType {\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return end(n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (isNumber(align)) return percent()\n    return predefined[align](n)\n  }\n\n  const self: AlignmentType = {\n    measure,\n  }\n  return self\n}\n", "type CallbackType = () => void\n\nexport type AnimationType = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): AnimationType {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: CallbackType): CallbackType {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: AnimationType = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n", "import { DirectionOptionType } from './Direction'\n\nexport type AxisOptionType = 'x' | 'y'\ntype AxisEdgeType = 'top' | 'right' | 'bottom' | 'left'\n\nexport type AxisType = {\n  scroll: AxisOptionType\n  cross: AxisOptionType\n  startEdge: AxisEdgeType\n  endEdge: AxisEdgeType\n  measureSize: (rect: DOMRect) => number\n}\n\nexport function Axis(\n  axis: AxisOptionType,\n  direction: DirectionOptionType,\n): AxisType {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n  const startEdge = getStartEdge()\n  const endEdge = getEndEdge()\n\n  function measureSize(rect: DOMRect): number {\n    const { width, height } = rect\n    return scroll === 'x' ? width : height\n  }\n\n  function getStartEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'top'\n    return direction === 'rtl' ? 'right' : 'left'\n  }\n\n  function getEndEdge(): AxisEdgeType {\n    if (scroll === 'y') return 'bottom'\n    return direction === 'rtl' ? 'left' : 'right'\n  }\n\n  const self: AxisType = {\n    scroll,\n    cross,\n    startEdge,\n    endEdge,\n    measureSize,\n  }\n  return self\n}\n", "import { mathAbs } from './utils'\n\nexport type LimitType = {\n  min: number\n  max: number\n  length: number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(min: number, max: number): LimitType {\n  const length = mathAbs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function constrain(n: number): number {\n    if (!reachedAny(n)) return n\n    return reachedMin(n) ? min : max\n  }\n\n  function removeOffset(n: number): number {\n    if (!length) return n\n    return n - length * Math.ceil((n - max) / length)\n  }\n\n  const self: LimitType = {\n    length,\n    max,\n    min,\n    constrain,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n", "import { Limit } from './Limit'\nimport { mathAbs } from './utils'\n\nexport type CounterType = {\n  get: () => number\n  set: (n: number) => CounterType\n  add: (n: number) => CounterType\n  clone: () => CounterType\n  min: number\n  max: number\n}\n\nexport function Counter(\n  max: number,\n  start: number,\n  loop: boolean,\n): CounterType {\n  const { min, constrain } = Limit(0, max)\n  const loopEnd = max + 1\n  let counter = withinLimit(start)\n\n  function withinLimit(n: number): number {\n    return !loop ? constrain(n) : mathAbs((loopEnd + n) % loopEnd)\n  }\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): CounterType {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): CounterType {\n    return set(get() + n)\n  }\n\n  function clone(): CounterType {\n    return Counter(max, get(), loop)\n  }\n\n  const self: CounterType = {\n    add,\n    clone,\n    get,\n    set,\n    min,\n    max,\n  }\n  return self\n}\n", "export type DirectionOptionType = 'ltr' | 'rtl'\n\nexport type DirectionType = {\n  apply: (n: number) => number\n}\n\nexport function Direction(direction: DirectionOptionType): DirectionType {\n  const sign = direction === 'rtl' ? -1 : 1\n\n  function apply(n: number): number {\n    return n * sign\n  }\n\n  const self: DirectionType = {\n    apply,\n  }\n  return self\n}\n", "type EventNameType = keyof DocumentEventMap | keyof WindowEventMap\ntype EventHandlerType = (evt: any) => void\ntype EventOptionsType = boolean | AddEventListenerOptions | undefined\ntype EventRemoverType = () => void\n\nexport type EventStoreType = {\n  add: (\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options?: EventOptionsType,\n  ) => EventStoreType\n  removeAll: () => EventStoreType\n}\n\nexport function EventStore(): EventStoreType {\n  let listeners: EventRemoverType[] = []\n\n  function add(\n    node: EventTarget,\n    type: EventNameType,\n    handler: EventHandlerType,\n    options: EventOptionsType = false,\n  ): EventStoreType {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => node.removeEventListener(type, handler, options))\n    return self\n  }\n\n  function removeAll(): EventStoreType {\n    listeners = listeners.filter((remove) => remove())\n    return self\n  }\n\n  const self: EventStoreType = {\n    add,\n    removeAll,\n  }\n  return self\n}\n", "import { isNumber } from './utils'\n\nexport type Vector1DType = {\n  get: () => number\n  set: (v: Vector1DType | number) => Vector1DType\n  add: (v: Vector1DType | number) => Vector1DType\n  subtract: (v: Vector1DType | number) => Vector1DType\n  multiply: (n: number) => Vector1DType\n  divide: (n: number) => Vector1DType\n  normalize: () => Vector1DType\n}\n\nexport function Vector1D(value: number): Vector1DType {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1DType | number): Vector1DType {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1DType | number): Vector1DType {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1DType | number): Vector1DType {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1DType {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1DType {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1DType {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1DType | number): number {\n    return isNumber(n) ? n : n.get()\n  }\n\n  const self: Vector1DType = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n", "import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { DirectionType } from './Direction'\nimport { DragTrackerType, PointerEventType } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { AxisType } from './Axis'\nimport { EventStore } from './EventStore'\nimport { ScrollBodyType } from './ScrollBody'\nimport { ScrollTargetType } from './ScrollTarget'\nimport { ScrollToType } from './ScrollTo'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { deltaAbs, factorAbs, mathAbs, mathSign } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type DragHandlerType = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeAllEvents: () => void\n}\n\nexport function DragHandler(\n  axis: AxisType,\n  direction: DirectionType,\n  rootNode: HTMLElement,\n  target: Vector1DType,\n  dragTracker: DragTrackerType,\n  location: Vector1DType,\n  animation: AnimationType,\n  scrollTo: ScrollToType,\n  scrollBody: ScrollBodyType,\n  scrollTarget: ScrollTargetType,\n  index: CounterType,\n  eventHandler: EventHandlerType,\n  percentOfView: PercentOfViewType,\n  loop: boolean,\n  dragFree: boolean,\n  skipSnaps: boolean,\n): DragHandlerType {\n  const { cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const dragThreshold = percentOfView.measure(20)\n  const snapForceBoost = { mouse: 300, touch: 400 }\n  const freeForceBoost = { mouse: 500, touch: 600 }\n  const baseSpeed = dragFree ? 5 : 16\n  const baseMass = 1\n\n  let startScroll = 0\n  let startCross = 0\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = rootNode\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? rootNode : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function removeAllEvents(): void {\n    activationEvents.removeAll()\n    interactionEvents.removeAll()\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function allowedForce(force: number, targetChanged: boolean): number {\n    const next = index.clone().add(mathSign(force) * -1)\n    const isEdge = next.get() === index.min || next.get() === index.max\n    const baseForce = scrollTarget.byDistance(force, !dragFree).distance\n\n    if (dragFree || mathAbs(force) < dragThreshold) return baseForce\n    if (!loop && isEdge) return baseForce * 0.4\n    if (skipSnaps && targetChanged) return baseForce * 0.5\n\n    return scrollTarget.byIndex(next.get(), 0).distance\n  }\n\n  function down(evt: PointerEventType): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = deltaAbs(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useBaseMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll = dragTracker.readPoint(evt)\n    startCross = dragTracker.readPoint(evt, crossAxis)\n    eventHandler.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: PointerEventType): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up(evt)\n      const lastScroll = dragTracker.readPoint(evt)\n      const lastCross = dragTracker.readPoint(evt, crossAxis)\n      const diffScroll = deltaAbs(lastScroll, startScroll)\n      const diffCross = deltaAbs(lastCross, startCross)\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up(evt)\n    }\n    const diff = dragTracker.pointerMove(evt)\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(direction.apply(diff))\n    evt.preventDefault()\n  }\n\n  function up(evt: PointerEventType): void {\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const rawForce = dragTracker.pointerUp(evt) * forceBoost()\n    const force = allowedForce(direction.apply(rawForce), targetChanged)\n    const forceFactor = factorAbs(rawForce, force)\n    const isMoving = deltaAbs(target.get(), dragStartPoint.get()) >= 0.5\n    const isVigorous = targetChanged && forceFactor > 0.75\n    const isBelowThreshold = mathAbs(rawForce) < dragThreshold\n    const speed = isVigorous ? 10 : baseSpeed\n    const mass = isVigorous ? baseMass + 2.5 * forceFactor : baseMass\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(isBelowThreshold ? 9 : speed).useMass(mass)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    eventHandler.emit('pointerUp')\n  }\n\n  function click(evt: MouseEvent): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandlerType = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeAllEvents,\n  }\n  return self\n}\n", "import { AxisOptionType, AxisType } from './Axis'\nimport { mathAbs } from './utils'\n\ntype PointerCoordType = keyof Touch | keyof MouseEvent\nexport type PointerEventType = TouchEvent | MouseEvent\n\nexport type DragTrackerType = {\n  isTouchEvent: (evt: PointerEventType) => evt is TouchEvent\n  pointerDown: (evt: PointerEventType) => number\n  pointerMove: (evt: PointerEventType) => number\n  pointerUp: (evt: PointerEventType) => number\n  readPoint: (evt: PointerEventType, evtAxis?: AxisOptionType) => number\n}\n\nexport function DragTracker(axis: AxisType): DragTrackerType {\n  const logInterval = 170\n\n  let startEvent: PointerEventType\n  let lastEvent: PointerEventType\n\n  function isTouchEvent(evt: PointerEventType): evt is TouchEvent {\n    return typeof TouchEvent !== 'undefined' && evt instanceof TouchEvent\n  }\n\n  function readTime(evt: PointerEventType): number {\n    return evt.timeStamp\n  }\n\n  function readPoint(evt: PointerEventType, evtAxis?: AxisOptionType): number {\n    const property = evtAxis || axis.scroll\n    const coord: PointerCoordType = `client${property === 'x' ? 'X' : 'Y'}`\n    return (isTouchEvent(evt) ? evt.touches[0] : evt)[coord]\n  }\n\n  function pointerDown(evt: PointerEventType): number {\n    startEvent = evt\n    lastEvent = evt\n    return readPoint(evt)\n  }\n\n  function pointerMove(evt: PointerEventType): number {\n    const diff = readPoint(evt) - readPoint(lastEvent)\n    const expired = readTime(evt) - readTime(startEvent) > logInterval\n\n    lastEvent = evt\n    if (expired) startEvent = evt\n    return diff\n  }\n\n  function pointerUp(evt: PointerEventType): number {\n    if (!startEvent || !lastEvent) return 0\n    const diffDrag = readPoint(lastEvent) - readPoint(startEvent)\n    const diffTime = readTime(evt) - readTime(startEvent)\n    const expired = readTime(evt) - readTime(lastEvent) > logInterval\n    const force = diffDrag / diffTime\n    const isFlick = diffTime && !expired && mathAbs(force) > 0.1\n\n    return isFlick ? force : 0\n  }\n\n  const self: DragTrackerType = {\n    isTouchEvent,\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n", "export type PercentOfViewType = {\n  measure: (n: number) => number\n}\n\nexport function PercentOfView(viewSize: number): PercentOfViewType {\n  function measure(n: number): number {\n    return viewSize * (n / 100)\n  }\n\n  const self: PercentOfViewType = {\n    measure,\n  }\n  return self\n}\n", "import { map, roundToDecimals, mathSign } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type ScrollBodyType = {\n  direction: () => number\n  seek: (target: Vector1DType) => ScrollBodyType\n  settle: (target: Vector1DType) => boolean\n  update: () => void\n  useBaseMass: () => ScrollBodyType\n  useBaseSpeed: () => ScrollBodyType\n  useMass: (n: number) => ScrollBodyType\n  useSpeed: (n: number) => ScrollBodyType\n}\n\nexport function ScrollBody(\n  location: Vector1DType,\n  baseSpeed: number,\n  baseMass: number,\n): ScrollBodyType {\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n\n  let attractionDirection = 0\n  let speed = baseSpeed\n  let mass = baseMass\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(force: Vector1DType): void {\n    force.divide(mass)\n    acceleration.add(force)\n  }\n\n  function seek(target: Vector1DType): ScrollBodyType {\n    attraction.set(target).subtract(location)\n    const magnitude = map(attraction.get(), 0, 100, 0, speed)\n    attractionDirection = mathSign(attraction.get())\n    attraction.normalize().multiply(magnitude).subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(target: Vector1DType): boolean {\n    const diff = target.get() - location.get()\n    const hasSettled = !roundToTwoDecimals(diff)\n    if (hasSettled) location.set(target)\n    return hasSettled\n  }\n\n  function direction(): number {\n    return attractionDirection\n  }\n\n  function useBaseSpeed(): ScrollBodyType {\n    return useSpeed(baseSpeed)\n  }\n\n  function useBaseMass(): ScrollBodyType {\n    return useMass(baseMass)\n  }\n\n  function useSpeed(n: number): ScrollBodyType {\n    speed = n\n    return self\n  }\n\n  function useMass(n: number): ScrollBodyType {\n    mass = n\n    return self\n  }\n\n  const self: ScrollBodyType = {\n    direction,\n    seek,\n    settle,\n    update,\n    useBaseMass,\n    useBaseSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n", "import { LimitType } from './Limit'\nimport { ScrollBodyType } from './ScrollBody'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs } from './utils'\nimport { PercentOfViewType } from './PercentOfView'\n\nexport type ScrollBoundsType = {\n  constrain: (pointerDown: boolean) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(\n  limit: LimitType,\n  location: Vector1DType,\n  target: Vector1DType,\n  scrollBody: ScrollBodyType,\n  percentOfView: PercentOfViewType,\n): ScrollBoundsType {\n  const pullBackThreshold = percentOfView.measure(10)\n  const edgeOffsetTolerance = percentOfView.measure(50)\n  const maxFriction = 0.85\n  let disabled = false\n\n  function shouldConstrain(): boolean {\n    if (disabled) return false\n    if (!limit.reachedAny(target.get())) return false\n    if (!limit.reachedAny(location.get())) return false\n    return true\n  }\n\n  function constrain(pointerDown: boolean): void {\n    if (!shouldConstrain()) return\n    const edge = limit.reachedMin(location.get()) ? 'min' : 'max'\n    const diffToEdge = mathAbs(limit[edge] - location.get())\n    const diffToTarget = target.get() - location.get()\n    const friction = Math.min(diffToEdge / edgeOffsetTolerance, maxFriction)\n\n    target.subtract(diffToTarget * friction)\n\n    if (!pointerDown && mathAbs(diffToTarget) < pullBackThreshold) {\n      target.set(limit.constrain(target.get()))\n      scrollBody.useSpeed(10).useMass(3)\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBoundsType = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n", "import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollContainOptionType = '' | 'trimSnaps' | 'keepSnaps'\n\nexport type ScrollContainType = {\n  snapsContained: number[]\n}\n\nexport function ScrollContain(\n  viewSize: number,\n  contentSize: number,\n  snapsAligned: number[],\n  containScroll: ScrollContainOptionType,\n): ScrollContainType {\n  const scrollBounds = Limit(-contentSize + viewSize, snapsAligned[0])\n  const snapsBounded = snapsAligned.map(scrollBounds.constrain)\n  const snapsContained = measureContained()\n\n  function findDuplicates(): LimitType {\n    const startSnap = snapsBounded[0]\n    const endSnap = arrayLast(snapsBounded)\n    const min = snapsBounded.lastIndexOf(startSnap)\n    const max = snapsBounded.indexOf(endSnap) + 1\n    return Limit(min, max)\n  }\n\n  function measureContained(): number[] {\n    if (contentSize <= viewSize) return [scrollBounds.max]\n    if (containScroll === 'keepSnaps') return snapsBounded\n    const { min, max } = findDuplicates()\n    return snapsBounded.slice(min, max)\n  }\n\n  const self: ScrollContainType = {\n    snapsContained,\n  }\n  return self\n}\n", "import { Limit, LimitType } from './Limit'\nimport { arrayLast } from './utils'\n\nexport type ScrollLimitType = {\n  limit: LimitType\n}\n\nexport function ScrollLimit(\n  contentSize: number,\n  scrollSnaps: number[],\n  loop: boolean,\n): ScrollLimitType {\n  const limit = measureLimit()\n\n  function measureLimit(): LimitType {\n    const startSnap = scrollSnaps[0]\n    const endSnap = arrayLast(scrollSnaps)\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit(min, max)\n  }\n\n  const self: ScrollLimitType = {\n    limit,\n  }\n  return self\n}\n", "import { Limit, LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollLooperType = {\n  loop: (direction: number) => void\n}\n\nexport function ScrollLooper(\n  contentSize: number,\n  limit: LimitType,\n  location: Vector1DType,\n  vectors: Vector1DType[],\n): ScrollLooperType {\n  const jointSafety = 0.1\n  const min = limit.min + jointSafety\n  const max = limit.max + jointSafety\n  const { reachedMin, reachedMax } = Limit(min, max)\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach((v) => v.add(loopDistance))\n  }\n\n  const self: ScrollLooperType = {\n    loop,\n  }\n  return self\n}\n", "import { LimitType } from './Limit'\n\nexport type ScrollProgressType = {\n  get: (n: number) => number\n}\n\nexport function ScrollProgress(limit: LimitType): ScrollProgressType {\n  const { max, length: scrollLength } = limit\n\n  function get(n: number): number {\n    const currentLocation = n - max\n    return currentLocation / -scrollLength\n  }\n\n  const self: ScrollProgressType = {\n    get,\n  }\n  return self\n}\n", "import { AlignmentType } from './Alignment'\nimport { AxisType } from './Axis'\nimport { SlidesToScrollType } from './SlidesToScroll'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type ScrollSnapsType = {\n  snaps: number[]\n  snapsAligned: number[]\n}\n\nexport function ScrollSnaps(\n  axis: AxisType,\n  alignment: AlignmentType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollType,\n  containScroll: boolean,\n): ScrollSnapsType {\n  const { startEdge, endEdge } = axis\n  const { groupSlides } = slidesToScroll\n  const alignments = measureSizes().map(alignment.measure)\n  const snaps = measureUnaligned()\n  const snapsAligned = measureAligned()\n\n  function measureSizes(): number[] {\n    return groupSlides(slideRects)\n      .map((rects) => arrayLast(rects)[endEdge] - rects[0][startEdge])\n      .map(mathAbs)\n  }\n\n  function measureUnaligned(): number[] {\n    return slideRects\n      .map((rect) => containerRect[startEdge] - rect[startEdge])\n      .map((snap) => -mathAbs(snap))\n  }\n\n  function measureAligned(): number[] {\n    const containedStartSnap = 0\n    const containedEndSnap = arrayLast(snaps) - arrayLast(slideSizesWithGaps)\n\n    return groupSlides(snaps)\n      .map((g) => g[0])\n      .map((snap, index, groupedSnaps) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(groupedSnaps)\n        if (containScroll && isFirst) return containedStartSnap\n        if (containScroll && isLast) return containedEndSnap\n        return snap + alignments[index]\n      })\n  }\n\n  const self: ScrollSnapsType = {\n    snaps,\n    snapsAligned,\n  }\n  return self\n}\n", "import { LimitType } from './Limit'\nimport { Vector1DType } from './Vector1d'\nimport { mathAbs, mathSign } from './utils'\n\nexport type TargetType = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTargetType = {\n  byIndex: (target: number, direction: number) => TargetType\n  byDistance: (force: number, snap: boolean) => TargetType\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(\n  loop: boolean,\n  scrollSnaps: number[],\n  contentSize: number,\n  limit: LimitType,\n  targetVector: Vector1DType,\n): ScrollTargetType {\n  const { reachedAny, removeOffset, constrain } = limit\n\n  function minDistance(distances: number[]): number {\n    return distances.concat().sort((a, b) => mathAbs(a) - mathAbs(b))[0]\n  }\n\n  function findTargetSnap(target: number): TargetType {\n    const distance = loop ? removeOffset(target) : constrain(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map((scrollSnap) => scrollSnap - distance)\n      .map((diffToSnap) => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => mathAbs(d1.diff) - mathAbs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const targets = [target, target + contentSize, target - contentSize]\n\n    if (!loop) return targets[0]\n    if (!direction) return minDistance(targets)\n\n    const matchingTargets = targets.filter((t) => mathSign(t) === direction)\n    return minDistance(matchingTargets)\n  }\n\n  function byIndex(index: number, direction: number): TargetType {\n    const diffToSnap = scrollSnaps[index] - targetVector.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): TargetType {\n    const target = targetVector.get() + distance\n    const { index, distance: targetSnapDistance } = findTargetSnap(target)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnapDistance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTargetType = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n", "import { AnimationType } from './Animation'\nimport { CounterType } from './Counter'\nimport { EventHandlerType } from './EventHandler'\nimport { ScrollTargetType, TargetType } from './ScrollTarget'\nimport { Vector1DType } from './Vector1d'\n\nexport type ScrollToType = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(\n  animation: AnimationType,\n  indexCurrent: CounterType,\n  indexPrevious: CounterType,\n  scrollTarget: ScrollTargetType,\n  targetVector: Vector1DType,\n  eventHandler: EventHandlerType,\n): ScrollToType {\n  function scrollTo(target: TargetType): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetVector.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      eventHandler.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollToType = {\n    distance,\n    index,\n  }\n  return self\n}\n", "import { AxisType } from './Axis'\nimport { DirectionType } from './Direction'\nimport { Vector1DType } from './Vector1d'\n\nexport type TranslateType = {\n  clear: () => void\n  to: (vector: Vector1DType) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(\n  axis: AxisType,\n  direction: DirectionType,\n  container: HTMLElement,\n): TranslateType {\n  const translate = axis.scroll === 'x' ? x : y\n  const containerStyle = container.style\n  let disabled = false\n\n  function x(n: number): string {\n    return `translate3d(${n}px,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}px,0px)`\n  }\n\n  function to(target: Vector1DType): void {\n    if (disabled) return\n    containerStyle.transform = translate(direction.apply(target.get()))\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    if (disabled) return\n    containerStyle.transform = ''\n    if (!container.getAttribute('style')) container.removeAttribute('style')\n  }\n\n  const self: TranslateType = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n", "import { AxisType } from './Axis'\nimport { arrayKeys } from './utils'\nimport { SlidesInViewType } from './SlidesInView'\nimport { Vector1D, Vector1DType } from './Vector1d'\nimport { Translate, TranslateType } from './Translate'\nimport { DirectionType } from './Direction'\n\ntype EdgeType = 'start' | 'end'\n\ntype LoopPointType = {\n  index: number\n  translate: TranslateType\n  location: Vector1DType\n  target: () => Vector1DType\n}\n\nexport type SlideLooperType = {\n  canLoop: () => boolean\n  clear: () => void\n  loop: () => void\n  loopPoints: LoopPointType[]\n}\n\nexport function SlideLooper(\n  axis: AxisType,\n  direction: DirectionType,\n  viewSize: number,\n  contentSize: number,\n  slideSizesWithGaps: number[],\n  scrollSnaps: number[],\n  slidesInView: SlidesInViewType,\n  scroll: Vector1DType,\n  slides: HTMLElement[],\n): SlideLooperType {\n  const ascItems = arrayKeys(slideSizesWithGaps)\n  const descItems = arrayKeys(slideSizesWithGaps).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n\n  function removeSlideSizes(indexes: number[], from: number): number {\n    return indexes.reduce((a: number, i) => {\n      return a - slideSizesWithGaps[i]\n    }, from)\n  }\n\n  function slidesInGap(indexes: number[], gap: number): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const remainingGap = removeSlideSizes(a, gap)\n      return remainingGap > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function findLoopPoints(indexes: number[], edge: EdgeType): LoopPointType[] {\n    const isStartEdge = edge === 'start'\n    const offset = isStartEdge ? -contentSize : contentSize\n    const slideBounds = slidesInView.findSlideBounds([offset])\n\n    return indexes.map((index) => {\n      const initial = isStartEdge ? 0 : -contentSize\n      const altered = isStartEdge ? contentSize : 0\n      const bounds = slideBounds.filter((b) => b.index === index)[0]\n      const point = bounds[isStartEdge ? 'end' : 'start']\n      const shift = Vector1D(-1)\n      const location = Vector1D(-1)\n      const translate = Translate(axis, direction, slides[index])\n      const target = () => shift.set(scroll.get() > point ? initial : altered)\n      return { index, location, translate, target }\n    })\n  }\n\n  function startPoints(): LoopPointType[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = slidesInGap(descItems, gap)\n    return findLoopPoints(indexes, 'end')\n  }\n\n  function endPoints(): LoopPointType[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = slidesInGap(ascItems, gap)\n    return findLoopPoints(indexes, 'start')\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter((i) => i !== index)\n      return removeSlideSizes(otherIndexes, viewSize) <= 0.1\n    })\n  }\n\n  function loop(): void {\n    loopPoints.forEach((loopPoint) => {\n      const { target, translate, location } = loopPoint\n      const shift = target()\n      if (shift.get() === location.get()) return\n      if (shift.get() === 0) translate.clear()\n      else translate.to(shift)\n      location.set(shift)\n    })\n  }\n\n  function clear(): void {\n    loopPoints.forEach((loopPoint) => loopPoint.translate.clear())\n  }\n\n  const self: SlideLooperType = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n", "import { Limit, LimitType } from './Limit'\n\nexport type SlideBoundType = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInViewType = {\n  check: (location: number, bounds?: SlideBoundType[]) => number[]\n  findSlideBounds: (offsets?: number[], threshold?: number) => SlideBoundType[]\n}\n\nexport function SlidesInView(\n  viewSize: number,\n  contentSize: number,\n  slideSizes: number[],\n  snaps: number[],\n  limit: LimitType,\n  loop: boolean,\n  inViewThreshold: number,\n): SlidesInViewType {\n  const { removeOffset, constrain } = limit\n  const roundingSafety = 0.5\n  const cachedOffsets = loop ? [0, contentSize, -contentSize] : [0]\n  const cachedBounds = findSlideBounds(cachedOffsets, inViewThreshold)\n\n  function findSlideThresholds(threshold?: number): number[] {\n    const slideThreshold = threshold || 0\n\n    return slideSizes.map((slideSize) => {\n      const thresholdLimit = Limit(roundingSafety, slideSize - roundingSafety)\n      return thresholdLimit.constrain(slideSize * slideThreshold)\n    })\n  }\n\n  function findSlideBounds(\n    offsets?: number[],\n    threshold?: number,\n  ): SlideBoundType[] {\n    const slideOffsets = offsets || cachedOffsets\n    const slideThresholds = findSlideThresholds(threshold)\n\n    return slideOffsets.reduce((list: SlideBoundType[], offset) => {\n      const bounds = snaps.map((snap, index) => ({\n        start: snap - slideSizes[index] + slideThresholds[index] + offset,\n        end: snap + viewSize - slideThresholds[index] + offset,\n        index,\n      }))\n      return list.concat(bounds)\n    }, [])\n  }\n\n  function check(location: number, bounds?: SlideBoundType[]): number[] {\n    const limitedLocation = loop ? removeOffset(location) : constrain(location)\n    const slideBounds = bounds || cachedBounds\n\n    return slideBounds.reduce((list: number[], slideBound) => {\n      const { index, start, end } = slideBound\n      const inList = list.indexOf(index) !== -1\n      const inView = start < limitedLocation && end > limitedLocation\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInViewType = {\n    check,\n    findSlideBounds,\n  }\n  return self\n}\n", "import { AxisType } from './Axis'\nimport { arrayLast, arrayLastIndex, mathAbs } from './utils'\n\nexport type SlideSizesType = {\n  slideSizes: number[]\n  slideSizesWithGaps: number[]\n}\n\nexport function SlideSizes(\n  axis: AxisType,\n  containerRect: DOMRect,\n  slideRects: DOMRect[],\n  slides: HTMLElement[],\n  includeEdgeGap: boolean,\n): SlideSizesType {\n  const { measureSize, startEdge, endEdge } = axis\n  const startGap = measureStartGap()\n  const endGap = measureEndGap()\n  const slideSizes = slideRects.map(measureSize)\n  const slideSizesWithGaps = measureWithGaps()\n\n  function measureStartGap(): number {\n    if (!includeEdgeGap) return 0\n    const slideRect = slideRects[0]\n    return mathAbs(containerRect[startEdge] - slideRect[startEdge])\n  }\n\n  function measureEndGap(): number {\n    if (!includeEdgeGap) return 0\n    const style = window.getComputedStyle(arrayLast(slides))\n    return parseFloat(style.getPropertyValue(`margin-${endEdge}`))\n  }\n\n  function measureWithGaps(): number[] {\n    return slideRects\n      .map((rect, index, rects) => {\n        const isFirst = !index\n        const isLast = index === arrayLastIndex(rects)\n        if (isFirst) return slideSizes[index] + startGap\n        if (isLast) return slideSizes[index] + endGap\n        return rects[index + 1][startEdge] - rect[startEdge]\n      })\n      .map(mathAbs)\n  }\n\n  const self: SlideSizesType = {\n    slideSizes,\n    slideSizesWithGaps,\n  }\n  return self\n}\n", "import { arrayKeys, arrayLast, isNumber } from './utils'\n\nexport type SlidesToScrollOptionType = 'auto' | number\n\nexport type SlidesToScrollType = {\n  groupSlides: <Type>(array: Type[]) => Type[][]\n}\n\nexport function SlidesToScroll(\n  viewSize: number,\n  slideSizesWithGaps: number[],\n  slidesToScroll: SlidesToScrollOptionType,\n): SlidesToScrollType {\n  const groupByNumber = isNumber(slidesToScroll)\n\n  function byNumber<Type>(array: Type[], groupSize: number): Type[][] {\n    return arrayKeys(array)\n      .filter((i) => i % groupSize === 0)\n      .map((i) => array.slice(i, i + groupSize))\n  }\n\n  function bySize<Type>(array: Type[]): Type[][] {\n    return arrayKeys(array)\n      .reduce((groupSizes: number[], i) => {\n        const chunk = slideSizesWithGaps.slice(arrayLast(groupSizes), i + 1)\n        const chunkSize = chunk.reduce((a, s) => a + s, 0)\n        return !i || chunkSize > viewSize ? groupSizes.concat(i) : groupSizes\n      }, [])\n      .map((start, i, groupSizes) => array.slice(start, groupSizes[i + 1]))\n  }\n\n  function groupSlides<Type>(array: Type[]): Type[][] {\n    return groupByNumber ? byNumber(array, slidesToScroll) : bySize(array)\n  }\n\n  const self: SlidesToScrollType = {\n    groupSlides,\n  }\n  return self\n}\n", "import { Alignment } from './Alignment'\nimport { Animation, AnimationType } from './Animation'\nimport { Axis, AxisType } from './Axis'\nimport { Counter, CounterType } from './Counter'\nimport { Direction, DirectionType } from './Direction'\nimport { DragHandler, DragHandlerType } from './DragHandler'\nimport { DragTracker } from './DragTracker'\nimport { EventHandlerType } from './EventHandler'\nimport { EventStore, EventStoreType } from './EventStore'\nimport { LimitType } from './Limit'\nimport { OptionsType } from './Options'\nimport { PercentOfView, PercentOfViewType } from './PercentOfView'\nimport { ScrollBody, ScrollBodyType } from './ScrollBody'\nimport { ScrollBounds, ScrollBoundsType } from './ScrollBounds'\nimport { ScrollContain } from './ScrollContain'\nimport { ScrollLimit } from './ScrollLimit'\nimport { ScrollLooper, ScrollLooperType } from './ScrollLooper'\nimport { ScrollProgress, ScrollProgressType } from './ScrollProgress'\nimport { ScrollSnaps } from './ScrollSnaps'\nimport { ScrollTarget, ScrollTargetType } from './ScrollTarget'\nimport { ScrollTo, ScrollToType } from './ScrollTo'\nimport { SlideLooper, SlideLooperType } from './SlideLooper'\nimport { SlidesInView, SlidesInViewType } from './SlidesInView'\nimport { SlideSizes } from './SlideSizes'\nimport { SlidesToScroll, SlidesToScrollType } from './SlidesToScroll'\nimport { Translate, TranslateType } from './Translate'\nimport { arrayKeys, arrayLast, arrayLastIndex } from './utils'\nimport { Vector1D, Vector1DType } from './Vector1d'\n\nexport type EngineType = {\n  axis: AxisType\n  direction: DirectionType\n  animation: AnimationType\n  scrollBounds: ScrollBoundsType\n  scrollLooper: ScrollLooperType\n  scrollProgress: ScrollProgressType\n  index: CounterType\n  indexPrevious: CounterType\n  limit: LimitType\n  location: Vector1DType\n  options: OptionsType\n  percentOfView: PercentOfViewType\n  scrollBody: ScrollBodyType\n  dragHandler: DragHandlerType\n  eventStore: EventStoreType\n  slideLooper: SlideLooperType\n  slidesInView: SlidesInViewType\n  slidesToScroll: SlidesToScrollType\n  target: Vector1DType\n  translate: TranslateType\n  scrollTo: ScrollToType\n  scrollTarget: ScrollTargetType\n  scrollSnaps: number[]\n  slideIndexes: number[]\n  containerRect: DOMRect\n  slideRects: DOMRect[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: OptionsType,\n  eventHandler: EventHandlerType,\n): EngineType {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    direction: contentDirection,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll: groupSlides,\n    skipSnaps,\n    containScroll,\n  } = options\n\n  // Measurements\n  const containerRect = container.getBoundingClientRect()\n  const slideRects = slides.map((slide) => slide.getBoundingClientRect())\n  const direction = Direction(contentDirection)\n  const axis = Axis(scrollAxis, contentDirection)\n  const viewSize = axis.measureSize(containerRect)\n  const percentOfView = PercentOfView(viewSize)\n  const alignment = Alignment(align, viewSize)\n  const containSnaps = !loop && containScroll !== ''\n  const includeEdgeGap = loop || containScroll !== ''\n  const { slideSizes, slideSizesWithGaps } = SlideSizes(\n    axis,\n    containerRect,\n    slideRects,\n    slides,\n    includeEdgeGap,\n  )\n  const slidesToScroll = SlidesToScroll(\n    viewSize,\n    slideSizesWithGaps,\n    groupSlides,\n  )\n  const { snaps, snapsAligned } = ScrollSnaps(\n    axis,\n    alignment,\n    containerRect,\n    slideRects,\n    slideSizesWithGaps,\n    slidesToScroll,\n    containSnaps,\n  )\n  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps)\n  const { snapsContained } = ScrollContain(\n    viewSize,\n    contentSize,\n    snapsAligned,\n    containScroll,\n  )\n  const scrollSnaps = containSnaps ? snapsContained : snapsAligned\n  const { limit } = ScrollLimit(contentSize, scrollSnaps, loop)\n\n  // Indexes\n  const index = Counter(arrayLastIndex(scrollSnaps), startIndex, loop)\n  const indexPrevious = index.clone()\n  const slideIndexes = arrayKeys(slides)\n\n  // Draw\n  const update = (): void => {\n    if (!loop) engine.scrollBounds.constrain(engine.dragHandler.pointerDown())\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (settled && !engine.dragHandler.pointerDown()) {\n      engine.animation.stop()\n      eventHandler.emit('settle')\n    }\n    if (!settled) {\n      eventHandler.emit('scroll')\n    }\n    if (loop) {\n      engine.scrollLooper.loop(engine.scrollBody.direction())\n      engine.slideLooper.loop()\n    }\n\n    engine.translate.to(location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const scrollBody = ScrollBody(location, speed, 1)\n  const scrollTarget = ScrollTarget(\n    loop,\n    scrollSnaps,\n    contentSize,\n    limit,\n    target,\n  )\n  const scrollTo = ScrollTo(\n    animation,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n    eventHandler,\n  )\n  const slidesInView = SlidesInView(\n    viewSize,\n    contentSize,\n    slideSizes,\n    snaps,\n    limit,\n    loop,\n    inViewThreshold,\n  )\n\n  // DragHandler\n  const dragHandler = DragHandler(\n    axis,\n    direction,\n    root,\n    target,\n    DragTracker(axis),\n    location,\n    animation,\n    scrollTo,\n    scrollBody,\n    scrollTarget,\n    index,\n    eventHandler,\n    percentOfView,\n    loop,\n    dragFree,\n    skipSnaps,\n  )\n\n  // Engine\n  const engine: EngineType = {\n    containerRect,\n    slideRects,\n    animation,\n    axis,\n    direction,\n    dragHandler,\n    eventStore: EventStore(),\n    percentOfView,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds(\n      limit,\n      location,\n      target,\n      scrollBody,\n      percentOfView,\n    ),\n    scrollLooper: ScrollLooper(contentSize, limit, location, [\n      location,\n      target,\n    ]),\n    scrollProgress: ScrollProgress(limit),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper(\n      axis,\n      direction,\n      viewSize,\n      contentSize,\n      slideSizesWithGaps,\n      scrollSnaps,\n      slidesInView,\n      location,\n      slides,\n    ),\n    slidesToScroll,\n    slidesInView,\n    slideIndexes,\n    target,\n    translate: Translate(axis, direction, container),\n  }\n  return engine\n}\n", "type CallbackType = (evt: EmblaEventType) => void\ntype ListenersType = Partial<{ [key in EmblaEventType]: CallbackType[] }>\n\nexport type EmblaEventType =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventHandlerType = {\n  emit: (evt: EmblaEventType) => EventHandlerType\n  on: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n  off: (evt: EmblaEventType, cb: CallbackType) => EventHandlerType\n}\n\nexport function EventHandler(): EventHandlerType {\n  const listeners: ListenersType = {}\n\n  function getListeners(evt: EmblaEventType): CallbackType[] {\n    return listeners[evt] || []\n  }\n\n  function emit(evt: EmblaEventType): EventHandlerType {\n    getListeners(evt).forEach((e) => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEventType, cb: CallbackType): EventHandlerType {\n    listeners[evt] = getListeners(evt).filter((e) => e !== cb)\n    return self\n  }\n\n  const self: EventHandlerType = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n", "import { AlignmentOptionType } from './Alignment'\nimport { AxisOptionType } from './Axis'\nimport { SlidesToScrollOptionType } from './SlidesToScroll'\nimport { DirectionOptionType } from './Direction'\nimport { ScrollContainOptionType } from './ScrollContain'\n\nexport type LooseOptionsType = {\n  [key: string]: unknown\n}\n\nexport type CreateOptionsType<Type extends LooseOptionsType> = Type & {\n  active: boolean\n  breakpoints: {\n    [key: string]: Omit<Partial<CreateOptionsType<Type>>, 'breakpoints'>\n  }\n}\n\nexport type OptionsType = CreateOptionsType<{\n  align: AlignmentOptionType\n  axis: AxisOptionType\n  containScroll: ScrollContainOptionType\n  direction: DirectionOptionType\n  slidesToScroll: SlidesToScrollOptionType\n  dragFree: boolean\n  draggable: boolean\n  inViewThreshold: number\n  loop: boolean\n  skipSnaps: boolean\n  speed: number\n  startIndex: number\n}>\n\nexport const defaultOptions: OptionsType = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  direction: 'ltr',\n  slidesToScroll: 1,\n  breakpoints: {},\n  dragFree: false,\n  draggable: true,\n  inViewThreshold: 0,\n  loop: false,\n  skipSnaps: false,\n  speed: 10,\n  startIndex: 0,\n  active: true,\n}\n\nexport type EmblaOptionsType = Partial<OptionsType>\n", "import { LooseOptionsType, CreateOptionsType } from './Options'\nimport { objectKeys, objectsAreEqual, objectsMergeDeep } from './utils'\n\ntype OptionsType = Partial<CreateOptionsType<LooseOptionsType>>\n\nexport type OptionsHandlerType = {\n  merge: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ) => TypeA\n  areEqual: <TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ) => boolean\n  atMedia: <Type extends OptionsType>(options: Type) => Type\n}\n\nexport function OptionsHandler(): OptionsHandlerType {\n  function merge<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB?: TypeB,\n  ): TypeA {\n    return <TypeA>objectsMergeDeep(optionsA, optionsB || {})\n  }\n\n  function areEqual<TypeA extends OptionsType, TypeB extends OptionsType>(\n    optionsA: TypeA,\n    optionsB: TypeB,\n  ): boolean {\n    const breakpointsA = JSON.stringify(objectKeys(optionsA.breakpoints || {}))\n    const breakpointsB = JSON.stringify(objectKeys(optionsB.breakpoints || {}))\n    if (breakpointsA !== breakpointsB) return false\n    return objectsAreEqual(optionsA, optionsB)\n  }\n\n  function atMedia<Type extends OptionsType>(options: Type): Type {\n    const optionsAtMedia = options.breakpoints || {}\n    const matchedMediaOptions = objectKeys(optionsAtMedia)\n      .filter((media) => window.matchMedia(media).matches)\n      .map((media) => optionsAtMedia[media])\n      .reduce((a, mediaOption) => merge(a, mediaOption), {})\n\n    return merge(options, matchedMediaOptions)\n  }\n\n  const self: OptionsHandlerType = {\n    merge,\n    areEqual,\n    atMedia,\n  }\n  return self\n}\n", "import { EmblaCarouselType } from '.'\nimport { OptionsHandler } from './OptionsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\ntype PluginChangedHandlerType = () => boolean\n\nexport type PluginsHandlerType = {\n  init: (\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ) => EmblaPluginsType\n  destroy: () => void\n  haveChanged: PluginChangedHandlerType\n}\n\nexport function PluginsHandler(): PluginsHandlerType {\n  const { atMedia, areEqual } = OptionsHandler()\n  let activePlugins: EmblaPluginType[] = []\n  let pluginsChanged: PluginChangedHandlerType[] = []\n\n  function haveChanged(): boolean {\n    return pluginsChanged.some((hasChanged) => hasChanged())\n  }\n\n  function hasChanged(plugin: EmblaPluginType): PluginChangedHandlerType {\n    const options = atMedia(plugin.options)\n    return (): boolean => !areEqual(options, atMedia(plugin.options))\n  }\n\n  function init(\n    plugins: EmblaPluginType[],\n    embla: EmblaCarouselType,\n  ): EmblaPluginsType {\n    pluginsChanged = plugins.map(hasChanged)\n    activePlugins = plugins.filter((plugin) => atMedia(plugin.options).active)\n    activePlugins.forEach((plugin) => plugin.init(embla))\n\n    return plugins.reduce((map, plugin) => {\n      return Object.assign(map, { [plugin.name]: plugin })\n    }, {})\n  }\n\n  function destroy(): void {\n    activePlugins = activePlugins.filter((plugin) => plugin.destroy())\n  }\n\n  const self: PluginsHandlerType = {\n    init,\n    destroy,\n    haveChanged,\n  }\n  return self\n}\n", "import { Engine, EngineType } from './Engine'\nimport { EventStore } from './EventStore'\nimport { EventHandler, EventHandlerType } from './EventHandler'\nimport { defaultOptions, EmblaOptionsType } from './Options'\nimport { OptionsHandler } from './OptionsHandler'\nimport { PluginsHandler } from './PluginsHandler'\nimport { EmblaPluginsType, EmblaPluginType } from './Plugins'\n\nexport type EmblaNodesType = {\n  root: HTMLElement\n  container?: HTMLElement\n  slides?: HTMLElement[]\n}\n\nexport type EmblaCarouselType = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  internalEngine: () => EngineType\n  destroy: () => void\n  off: EventHandlerType['off']\n  on: EventHandlerType['on']\n  plugins: () => EmblaPluginsType\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptionsType, plugins?: EmblaPluginType[]) => void\n  rootNode: () => HTMLElement\n  scrollNext: (jump?: boolean) => void\n  scrollPrev: (jump?: boolean) => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number, jump?: boolean) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  nodes: HTMLElement | EmblaNodesType,\n  userOptions?: EmblaOptionsType,\n  userPlugins?: EmblaPluginType[],\n): EmblaCarouselType {\n  const resizeHandlers = EventStore()\n  const optionsHandler = OptionsHandler()\n  const pluginsHandler = PluginsHandler()\n  const eventHandler = EventHandler()\n  const { on, off } = eventHandler\n  const reInit = reActivate\n\n  let destroyed = false\n  let engine: EngineType\n  let optionsBase = optionsHandler.merge(\n    defaultOptions,\n    EmblaCarousel.globalOptions,\n  )\n  let options = optionsHandler.merge(optionsBase)\n  let pluginList: EmblaPluginType[] = []\n  let pluginApis: EmblaPluginsType\n  let rootSize = 0\n  let root: HTMLElement\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  function storeElements(): void {\n    const providedContainer = 'container' in nodes && nodes.container\n    const providedSlides = 'slides' in nodes && nodes.slides\n\n    root = 'root' in nodes ? nodes.root : nodes\n    container = providedContainer || <HTMLElement>root.children[0]\n    slides = providedSlides || [].slice.call(container.children)\n  }\n\n  function activate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    if (destroyed) return\n    storeElements()\n\n    optionsBase = optionsHandler.merge(optionsBase, withOptions)\n    options = optionsHandler.atMedia(optionsBase)\n    engine = Engine(root, container, slides, options, eventHandler)\n    rootSize = engine.axis.measureSize(root.getBoundingClientRect())\n\n    if (!options.active) return deActivate()\n\n    engine.translate.to(engine.location)\n    pluginList = withPlugins || pluginList\n    pluginApis = pluginsHandler.init(pluginList, self)\n\n    if (options.loop) {\n      if (!engine.slideLooper.canLoop()) {\n        deActivate()\n        return activate({ loop: false }, withPlugins)\n      }\n      engine.slideLooper.loop()\n    }\n    if (options.draggable && container.offsetParent && slides.length) {\n      engine.dragHandler.addActivationEvents()\n    }\n  }\n\n  function reActivate(\n    withOptions?: EmblaOptionsType,\n    withPlugins?: EmblaPluginType[],\n  ): void {\n    const startIndex = selectedScrollSnap()\n    deActivate()\n    activate(optionsHandler.merge({ startIndex }, withOptions), withPlugins)\n    eventHandler.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeAllEvents()\n    engine.animation.stop()\n    engine.eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear()\n    pluginsHandler.destroy()\n  }\n\n  function destroy(): void {\n    if (destroyed) return\n    destroyed = true\n    resizeHandlers.removeAll()\n    deActivate()\n    eventHandler.emit('destroy')\n  }\n\n  function resize(): void {\n    const newOptions = optionsHandler.atMedia(optionsBase)\n    const optionsChanged = !optionsHandler.areEqual(newOptions, options)\n    const newRootSize = engine.axis.measureSize(root.getBoundingClientRect())\n    const rootSizeChanged = rootSize !== newRootSize\n    const pluginsChanged = pluginsHandler.haveChanged()\n\n    if (rootSizeChanged || optionsChanged || pluginsChanged) reActivate()\n    eventHandler.emit('resize')\n  }\n\n  function slidesInView(target?: boolean): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target?: boolean): number[] {\n    const inView = slidesInView(target)\n    return engine.slideIndexes.filter((index) => inView.indexOf(index) === -1)\n  }\n\n  function scrollTo(index: number, jump?: boolean, direction?: number): void {\n    if (!options.active || destroyed) return\n    engine.scrollBody.useBaseMass().useSpeed(jump ? 100 : options.speed)\n    engine.scrollTo.index(index, direction || 0)\n  }\n\n  function scrollNext(jump?: boolean): void {\n    const next = engine.index.clone().add(1)\n    scrollTo(next.get(), jump === true, -1)\n  }\n\n  function scrollPrev(jump?: boolean): void {\n    const prev = engine.index.clone().add(-1)\n    scrollTo(prev.get(), jump === true, 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function plugins(): EmblaPluginsType {\n    return pluginApis\n  }\n\n  function internalEngine(): EngineType {\n    return engine\n  }\n\n  function rootNode(): HTMLElement {\n    return root\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarouselType = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    internalEngine,\n    destroy,\n    off,\n    on,\n    plugins,\n    previousScrollSnap,\n    reInit,\n    rootNode,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n\n  activate(userOptions, userPlugins)\n  resizeHandlers.add(window, 'resize', resize)\n  setTimeout(() => eventHandler.emit('init'), 0)\n  return self\n}\n\nEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\nEmblaCarousel.optionsHandler = OptionsHandler\n\nexport default EmblaCarousel\n", "import EmblaCarousel, { EmblaPluginType } from 'embla-carousel'\n\nexport function canUseDOM(): boolean {\n  return !!(\n    typeof window !== 'undefined' &&\n    window.document &&\n    window.document.createElement\n  )\n}\n\nexport function sortAndMapPluginToOptions(\n  plugins: EmblaPluginType[],\n): EmblaPluginType['options'][] {\n  return plugins\n    .concat()\n    .sort((a, b) => (a.name > b.name ? 1 : -1))\n    .map((plugin) => plugin.options)\n}\n\nexport function arePluginsEqual(\n  pluginsA: EmblaPluginType[],\n  pluginsB: EmblaPluginType[],\n): boolean {\n  if (pluginsA.length !== pluginsB.length) return false\n\n  const { areEqual } = EmblaCarousel.optionsHandler()\n  const optionsA = sortAndMapPluginToOptions(pluginsA)\n  const optionsB = sortAndMapPluginToOptions(pluginsB)\n\n  return optionsA.every((optionA, index) => {\n    const optionB = optionsB[index]\n    return areEqual(optionA, optionB)\n  })\n}\n", "import { useRef, useEffect, useState, useCallback } from 'react'\nimport { arePluginsEqual, canUseDOM } from './utils'\nimport EmblaCarousel, {\n  EmblaCarouselType,\n  EmblaOptionsType,\n  EmblaPluginType,\n} from 'embla-carousel'\n\ntype EmblaViewportRefType = <ViewportElement extends HTMLElement>(\n  instance: ViewportElement | null,\n) => void\n\nexport type UseEmblaCarouselType = [\n  EmblaViewportRefType,\n  EmblaCarouselType | undefined,\n]\n\nfunction useEmblaCarousel(\n  options: EmblaOptionsType = {},\n  plugins: EmblaPluginType[] = [],\n): UseEmblaCarouselType {\n  const optionsHandler = useRef(EmblaCarousel.optionsHandler())\n  const storedOptions = useRef(options)\n  const storedPlugins = useRef(plugins)\n  const [embla, setEmbla] = useState<EmblaCarouselType>()\n  const [viewport, setViewport] = useState<HTMLElement>()\n\n  const reInit = useCallback(() => {\n    if (embla) embla.reInit(storedOptions.current, storedPlugins.current)\n  }, [embla])\n\n  useEffect(() => {\n    if (canUseDOM() && viewport) {\n      EmblaCarousel.globalOptions = useEmblaCarousel.globalOptions\n      const newEmbla = EmblaCarousel(\n        viewport,\n        storedOptions.current,\n        storedPlugins.current,\n      )\n      setEmbla(newEmbla)\n      return () => newEmbla.destroy()\n    } else {\n      setEmbla(undefined)\n    }\n  }, [viewport, setEmbla])\n\n  useEffect(() => {\n    if (optionsHandler.current.areEqual(storedOptions.current, options)) return\n\n    storedOptions.current = options\n    reInit()\n  }, [options, reInit])\n\n  useEffect(() => {\n    if (arePluginsEqual(storedPlugins.current, plugins)) return\n\n    storedPlugins.current = plugins\n    reInit()\n  }, [plugins, reInit])\n\n  return [<EmblaViewportRefType>setViewport, embla]\n}\n\nuseEmblaCarousel.globalOptions = <EmblaOptionsType | undefined>undefined\n\nexport default useEmblaCarousel\n", "export const CAROUSEL_ERRORS = {\n  context: '[@mantine/carousel] Carousel.Slide was rendered outside of Carousel context',\n};\n", "import { MantineNumberSize, Styles, ClassNames } from '@mantine/core';\nimport { createSafeContext } from '@mantine/utils';\nimport { CAROUSEL_ERRORS } from './Carousel.errors';\nimport { CarouselOrientation, Embla, CarouselBreakpoint } from './types';\nimport type { CarouselStylesNames } from './Carousel';\n\ninterface CarouselContext {\n  embla: Embla;\n  slideSize: string | number;\n  slideGap: MantineNumberSize;\n  orientation: CarouselOrientation;\n  includeGapInSize: boolean;\n  breakpoints: CarouselBreakpoint[];\n  classNames: ClassNames<CarouselStylesNames>;\n  styles: Styles<CarouselStylesNames>;\n  unstyled: boolean;\n}\n\nexport const [CarouselProvider, useCarouselContext] = createSafeContext<CarouselContext>(\n  CAROUSEL_ERRORS.context\n);\n", "import { createStyles, MantineNumberSize, getSortedBreakpoints } from '@mantine/core';\nimport { CarouselOrientation, CarouselBreakpoint } from '../types';\n\nexport interface CarouselSlideStylesParams {\n  size: string | number;\n  gap: MantineNumberSize;\n  orientation: CarouselOrientation;\n  includeGapInSize: boolean;\n  breakpoints: CarouselBreakpoint[];\n}\n\nexport default createStyles(\n  (\n    theme,\n    { size, gap, orientation, includeGapInSize, breakpoints = [] }: CarouselSlideStylesParams\n  ) => {\n    // Slide styles by slideGap and slideSize\n    const getSlideStyles = (slideGap: MantineNumberSize, slideSize: string | number) => {\n      const slideGapValue = theme.fn.size({\n        size: slideGap,\n        sizes: theme.spacing,\n      });\n\n      const flexBasisValue = typeof slideSize === 'number' ? `${slideSize}px` : slideSize;\n\n      const marginStyles = includeGapInSize\n        ? {\n            [orientation === 'horizontal' ? 'paddingRight' : 'paddinBottom']: slideGapValue,\n          }\n        : {\n            [orientation === 'horizontal' ? 'marginRight' : 'marginBottom']: slideGapValue,\n          };\n\n      return {\n        flex: `0 0 ${flexBasisValue}`,\n        ...marginStyles,\n      };\n    };\n\n    const hasDiff = breakpoints.some(\n      (v) => typeof v.slideGap !== 'undefined' || typeof v.slideSize !== 'undefined'\n    );\n\n    // Apply styles for breakpoints only if has different gap or size\n    const slideBreakpoints = !hasDiff\n      ? null\n      : getSortedBreakpoints(theme, breakpoints).reduce((acc, breakpoint) => {\n          const property = 'maxWidth' in breakpoint ? 'max-width' : 'min-width';\n          const breakpointSize = theme.fn.size({\n            size: property === 'max-width' ? breakpoint.maxWidth : breakpoint.minWidth,\n            sizes: theme.breakpoints,\n          });\n\n          const breakpointGap =\n            typeof breakpoint.slideGap === 'undefined' ? gap : breakpoint.slideGap;\n\n          acc[`@media (${property}: ${breakpointSize - (property === 'max-width' ? 1 : 0)}px)`] =\n            getSlideStyles(breakpointGap, breakpoint.slideSize);\n\n          return acc;\n        }, {});\n\n    return {\n      slide: {\n        position: 'relative',\n        ...getSlideStyles(gap, size),\n        ...slideBreakpoints,\n      },\n    };\n  }\n);\n", "import React, { forwardRef, useCallback } from 'react';\nimport { Box, DefaultProps, Selectors, MantineNumberSize } from '@mantine/core';\nimport { useCarouselContext } from '../Carousel.context';\nimport useStyles from './CarouselSlide.styles';\n\nexport type CarouselSlideStylesNames = Selectors<typeof useStyles>;\n\nexport interface CarouselSlideProps extends DefaultProps, React.ComponentPropsWithoutRef<'div'> {\n  /** Slide content */\n  children?: React.ReactNode;\n\n  /** Slide width, defaults to 100%, examples: 200px, 50% */\n  size?: string | number;\n\n  /** Key of theme.spacing or number to set gap between slides in px */\n  gap?: MantineNumberSize;\n}\n\nexport const CarouselSlide = forwardRef<HTMLDivElement, CarouselSlideProps>(\n  ({ children, className, size, gap, onClick, ...others }, ref) => {\n    const ctx = useCarouselContext();\n    const { classes, cx } = useStyles(\n      {\n        gap: typeof gap === 'undefined' ? ctx.slideGap : gap,\n        size: typeof size === 'undefined' ? ctx.slideSize : size,\n        orientation: ctx.orientation,\n        includeGapInSize: ctx.includeGapInSize,\n        breakpoints: ctx.breakpoints,\n      },\n      { name: 'Carousel', classNames: ctx.classNames, styles: ctx.styles, unstyled: ctx.unstyled }\n    );\n\n    const handleClick = useCallback(\n      (event: React.MouseEvent<HTMLDivElement, MouseEvent>) => {\n        if (ctx.embla?.clickAllowed()) {\n          onClick?.(event);\n        }\n      },\n      [ctx.embla]\n    );\n\n    return (\n      <Box className={cx(classes.slide, className)} ref={ref} onClick={handleClick} {...others}>\n        {children}\n      </Box>\n    );\n  }\n);\n\nCarouselSlide.displayName = '@mantine/carousel/CarouselSlide';\n", "import { CarouselOrientation } from './types';\n\ninterface Options {\n  dir: 'rtl' | 'ltr';\n  orientation: CarouselOrientation;\n  direction: 'next' | 'previous';\n}\n\nexport function getChevronRotation({ dir, orientation, direction }: Options) {\n  if (direction === 'previous') {\n    return orientation === 'horizontal' ? 90 * (dir === 'ltr' ? 1 : -1) : -180;\n  }\n\n  return orientation === 'horizontal' ? 90 * (dir === 'ltr' ? -1 : 1) : 0;\n}\n", "import { createStyles, getSortedBreakpoints, MantineNumberSize } from '@mantine/core';\nimport { CarouselBreakpoint } from './types';\n\nexport interface CarouselStylesParams {\n  controlSize: number;\n  controlsOffset: MantineNumberSize;\n  orientation: 'vertical' | 'horizontal';\n  height: React.CSSProperties['height'];\n  includeGapInSize: boolean;\n  breakpoints: CarouselBreakpoint[];\n  slideGap: MantineNumberSize;\n}\n\nexport default createStyles(\n  (\n    theme,\n    {\n      controlSize,\n      controlsOffset,\n      orientation,\n      height,\n      includeGapInSize,\n      breakpoints = [],\n      slideGap,\n    }: CarouselStylesParams\n  ) => {\n    const horizontal = orientation === 'horizontal';\n\n    // Container styles by slideGap (for includeGapInSize case)\n    const getContainerStyles = (gap: MantineNumberSize) => {\n      if (!includeGapInSize) return {};\n\n      const slideGapValue = theme.fn.size({\n        size: gap,\n        sizes: theme.spacing,\n      });\n\n      return {\n        [orientation === 'horizontal' ? 'marginRight' : 'marginBottom']: slideGapValue * -1,\n      };\n    };\n\n    const hasDiff = breakpoints.some(\n      (v) => typeof v.slideGap !== 'undefined' || typeof v.slideSize !== 'undefined'\n    );\n\n    // Apply styles for breakpoints only if has different gap or size\n    const containerBreakpoints = !hasDiff\n      ? null\n      : getSortedBreakpoints(theme, breakpoints).reduce((acc, breakpoint) => {\n          const property = 'maxWidth' in breakpoint ? 'max-width' : 'min-width';\n          const breakpointSize = theme.fn.size({\n            size: (property === 'max-width' ? breakpoint.maxWidth : breakpoint.minWidth)!,\n            sizes: theme.breakpoints,\n          });\n\n          const breakpointSlideGap =\n            (typeof breakpoint.slideGap === 'undefined' ? slideGap : breakpoint.slideGap) ?? 0;\n\n          acc[`@media (${property}: ${breakpointSize - (property === 'max-width' ? 1 : 0)}px)`] =\n            getContainerStyles(breakpointSlideGap);\n\n          return acc;\n        }, {} as any);\n\n    return {\n      root: {\n        position: 'relative',\n      },\n      viewport: {\n        height,\n        overflow: 'hidden',\n      },\n\n      container: {\n        display: 'flex',\n        flexDirection: horizontal ? 'row' : 'column',\n        height,\n        ...getContainerStyles(slideGap),\n        ...containerBreakpoints,\n      },\n\n      controls: {\n        position: 'absolute',\n        zIndex: 1,\n        left: horizontal ? 0 : `calc(50% - ${controlSize / 2}px)`,\n        right: horizontal ? 0 : undefined,\n        top: horizontal ? `calc(50% - ${controlSize / 2}px)` : 0,\n        bottom: horizontal ? undefined : 0,\n        display: 'flex',\n        flexDirection: horizontal ? 'row' : 'column',\n        alignItems: 'center',\n        justifyContent: 'space-between',\n        paddingLeft: horizontal\n          ? theme.fn.size({ size: controlsOffset, sizes: theme.spacing })\n          : undefined,\n        paddingRight: horizontal\n          ? theme.fn.size({ size: controlsOffset, sizes: theme.spacing })\n          : undefined,\n        paddingTop: !horizontal\n          ? theme.fn.size({ size: controlsOffset, sizes: theme.spacing })\n          : undefined,\n        paddingBottom: !horizontal\n          ? theme.fn.size({ size: controlsOffset, sizes: theme.spacing })\n          : undefined,\n        pointerEvents: 'none',\n      },\n\n      control: {\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        minWidth: controlSize,\n        minHeight: controlSize,\n        borderRadius: controlSize,\n        pointerEvents: 'all',\n        backgroundColor: theme.white,\n        color: theme.black,\n        boxShadow: theme.shadows.md,\n        opacity: theme.colorScheme === 'dark' ? 0.65 : 0.85,\n        border: `1px solid ${theme.colors.gray[3]}`,\n        transition: `opacity 150ms ${theme.transitionTimingFunction}`,\n        ...theme.fn.hover({ opacity: 1 }),\n        '&:active': theme.activeStyles,\n      },\n\n      indicators: {\n        position: 'absolute',\n        bottom: horizontal ? theme.spacing.md : 0,\n        top: horizontal ? undefined : 0,\n        left: horizontal ? 0 : undefined,\n        right: horizontal ? 0 : theme.spacing.md,\n        display: 'flex',\n        flexDirection: horizontal ? 'row' : 'column',\n        justifyContent: 'center',\n        gap: 8,\n        pointerEvents: 'none',\n      },\n\n      indicator: {\n        pointerEvents: 'all',\n        width: horizontal ? 25 : 5,\n        height: horizontal ? 5 : 25,\n        borderRadius: 10000,\n        backgroundColor: theme.white,\n        boxShadow: theme.shadows.sm,\n        opacity: 0.6,\n        transition: `opacity 150ms ${theme.transitionTimingFunction}`,\n\n        '&[data-active]': {\n          opacity: 1,\n        },\n      },\n    };\n  }\n);\n", "/* eslint-disable react/no-unused-prop-types */\nimport React, { forwardRef, useEffect, useCallback, useState, Children } from 'react';\nimport {\n  useComponentDefaultProps,\n  Box,\n  DefaultProps,\n  UnstyledButton,\n  ChevronIcon,\n  MantineNumberSize,\n  Selectors,\n} from '@mantine/core';\nimport { clamp } from '@mantine/hooks';\nimport useEmblaCarousel, { EmblaPluginType } from 'embla-carousel-react';\nimport { ForwardRefWithStaticComponents } from '@mantine/utils';\nimport { CarouselSlide, CarouselSlideStylesNames } from './CarouselSlide/CarouselSlide';\nimport { CarouselProvider } from './Carousel.context';\nimport { CarouselOrientation, Embla, CarouselBreakpoint } from './types';\nimport { getChevronRotation } from './get-chevron-rotation';\nimport useStyles, { CarouselStylesParams } from './Carousel.styles';\n\nexport type CarouselStylesNames = CarouselSlideStylesNames | Selectors<typeof useStyles>;\n\nexport interface CarouselProps\n  extends DefaultProps<CarouselStylesNames, CarouselStylesParams>,\n    React.ComponentPropsWithRef<'div'> {\n  /** <Carousel.Slide /> components */\n  children?: React.ReactNode;\n\n  /** Called when user clicks next button */\n  onNextSlide?(): void;\n\n  /** Called when user clicks previous button */\n  onPreviousSlide?(): void;\n\n  /** Called with slide index when slide changes */\n  onSlideChange?(index: number): void;\n\n  /** Get embla API as ref */\n  getEmblaApi?(embla: Embla): void;\n\n  /** Next control aria-label */\n  nextControlLabel?: string;\n\n  /** Previous control aria-label */\n  previousControlLabel?: string;\n\n  /** Previous/next controls size in px */\n  controlSize?: number;\n\n  /** Key of theme.spacing or number to set space between next/previous control and carousel boundary */\n  controlsOffset?: MantineNumberSize;\n\n  /** Slide width, defaults to 100%, examples: 200px, 50% */\n  slideSize?: string | number;\n\n  /** Key of theme.spacing or number to set gap between slides in px */\n  slideGap?: MantineNumberSize;\n\n  /** Control slideSize and slideGap at different viewport sizes */\n  breakpoints?: CarouselBreakpoint[];\n\n  /** Carousel orientation, horizontal by default */\n  orientation?: CarouselOrientation;\n\n  /** Slides container height, required for vertical orientation */\n  height?: React.CSSProperties['height'];\n\n  /** Determines how slides will be aligned relative to the container. Use number between 0-1 to align slides based on percentage, where 0.5 equals 50% */\n  align?: 'start' | 'center' | 'end' | number;\n\n  /** Number of slides that should be scrolled with next/previous buttons */\n  slidesToScroll?: number | 'auto';\n\n  /** Determines whether gap should be treated as part of the slide size, true by default */\n  includeGapInSize?: boolean;\n\n  /** Determines whether carousel can be scrolled with mouse and touch interactions, true by default */\n  draggable?: boolean;\n\n  /** Determines whether momentum scrolling should be enabled, false by default */\n  dragFree?: boolean;\n\n  /** Enables infinite looping. Automatically falls back to false if slide content isn't enough to loop. */\n  loop?: boolean;\n\n  /** Adjusts scroll speed when triggered by any of the methods. Higher numbers enables faster scrolling. */\n  speed?: number;\n\n  /** Index of initial slide */\n  initialSlide?: number;\n\n  /** Choose a fraction representing the percentage portion of a slide that needs to be visible in order to be considered in view. For example, 0.5 equals 50%. */\n  inViewThreshold?: number;\n\n  /** Determines whether next/previous controls should be displayed, true by default */\n  withControls?: boolean;\n\n  /** Determines whether indicators should be displayed, false by default */\n  withIndicators?: boolean;\n\n  /** An array of embla plugins */\n  plugins?: EmblaPluginType[];\n\n  /** Icon of next control */\n  nextControlIcon?: React.ReactNode;\n\n  /** Previous control icon */\n  previousControlIcon?: React.ReactNode;\n\n  /** Allow the carousel to skip scroll snaps if it's dragged vigorously. Note that this option will be ignored if the dragFree option is set to true, false by default */\n  skipSnaps?: boolean;\n\n  /** Clear leading and trailing empty space that causes excessive scrolling. Use trimSnaps to only use snap points that trigger scrolling or keepSnaps to keep them. */\n  containScroll?: 'trimSnaps' | 'keepSnaps' | '';\n\n  /** Determines whether arrow key should switch slides, true by default */\n  withKeyboardEvents?: boolean;\n}\n\nconst defaultProps: Partial<CarouselProps> = {\n  controlSize: 26,\n  controlsOffset: 'sm',\n  slideSize: '100%',\n  slideGap: 0,\n  orientation: 'horizontal',\n  align: 'center',\n  slidesToScroll: 1,\n  includeGapInSize: true,\n  draggable: true,\n  dragFree: false,\n  loop: false,\n  speed: 10,\n  initialSlide: 0,\n  inViewThreshold: 0,\n  withControls: true,\n  withIndicators: false,\n  skipSnaps: false,\n  containScroll: '',\n  withKeyboardEvents: true,\n};\n\nexport const _Carousel = forwardRef<HTMLDivElement, CarouselProps>((props, ref) => {\n  const {\n    children,\n    className,\n    getEmblaApi,\n    onNextSlide,\n    onPreviousSlide,\n    onSlideChange,\n    nextControlLabel,\n    previousControlLabel,\n    controlSize,\n    controlsOffset,\n    classNames,\n    styles,\n    unstyled,\n    slideSize,\n    slideGap,\n    orientation,\n    height,\n    align,\n    slidesToScroll,\n    includeGapInSize,\n    draggable,\n    dragFree,\n    loop,\n    speed,\n    initialSlide,\n    inViewThreshold,\n    withControls,\n    withIndicators,\n    plugins,\n    nextControlIcon,\n    previousControlIcon,\n    breakpoints,\n    skipSnaps,\n    containScroll,\n    withKeyboardEvents,\n    ...others\n  } = useComponentDefaultProps('Carousel', defaultProps, props);\n\n  const { classes, cx, theme } = useStyles(\n    { controlSize, controlsOffset, orientation, height, includeGapInSize, breakpoints, slideGap },\n    { name: 'Carousel', classNames, styles, unstyled }\n  );\n\n  const [emblaRefElement, embla] = useEmblaCarousel(\n    {\n      axis: orientation === 'horizontal' ? 'x' : 'y',\n      direction: theme.dir,\n      startIndex: initialSlide,\n      loop,\n      align,\n      slidesToScroll,\n      draggable,\n      dragFree,\n      speed,\n      inViewThreshold,\n      skipSnaps,\n      containScroll,\n    },\n    plugins\n  );\n\n  const [selected, setSelected] = useState(0);\n  const [slidesCount, setSlidesCount] = useState(0);\n\n  const handleScroll = useCallback((index: number) => embla && embla.scrollTo(index), [embla]);\n\n  const handleSelect = useCallback(() => {\n    if (!embla) return;\n    const slide = embla.selectedScrollSnap();\n    setSelected(slide);\n    onSlideChange?.(slide);\n  }, [embla, setSelected]);\n\n  const handlePrevious = useCallback(() => {\n    embla?.scrollPrev();\n    onPreviousSlide?.();\n  }, [embla]);\n\n  const handleNext = useCallback(() => {\n    embla?.scrollNext();\n    onNextSlide?.();\n  }, [embla]);\n\n  const handleKeydown = useCallback(\n    (event: React.KeyboardEvent<HTMLDivElement>) => {\n      if (withKeyboardEvents) {\n        if (event.key === 'ArrowRight') {\n          event.preventDefault();\n          handleNext();\n        }\n\n        if (event.key === 'ArrowLeft') {\n          event.preventDefault();\n          handlePrevious();\n        }\n      }\n    },\n    [embla]\n  );\n\n  useEffect(() => {\n    if (embla) {\n      getEmblaApi?.(embla);\n      handleSelect();\n      setSlidesCount(embla.scrollSnapList().length);\n      embla.on('select', handleSelect);\n\n      return () => {\n        embla.off('select', handleSelect);\n      };\n    }\n\n    return undefined;\n  }, [embla, slidesToScroll]);\n\n  useEffect(() => {\n    if (embla) {\n      embla.reInit();\n      setSlidesCount(embla.scrollSnapList().length);\n      setSelected((currentSelected) =>\n        clamp(currentSelected, 0, Children.toArray(children).length - 1)\n      );\n    }\n  }, [Children.toArray(children).length, slidesToScroll]);\n\n  const canScrollPrev = embla?.canScrollPrev() || false;\n  const canScrollNext = embla?.canScrollNext() || false;\n\n  const indicators = Array(slidesCount)\n    .fill(0)\n    .map((_, index) => (\n      <UnstyledButton\n        key={index}\n        data-active={index === selected || undefined}\n        className={classes.indicator}\n        aria-hidden\n        tabIndex={-1}\n        onClick={() => handleScroll(index)}\n      />\n    ));\n\n  return (\n    <CarouselProvider\n      value={{\n        slideGap,\n        slideSize,\n        embla,\n        orientation,\n        includeGapInSize,\n        breakpoints,\n        classNames,\n        styles,\n        unstyled,\n      }}\n    >\n      <Box\n        className={cx(classes.root, className)}\n        ref={ref}\n        onKeyDownCapture={handleKeydown}\n        {...others}\n      >\n        <div className={classes.viewport} ref={emblaRefElement}>\n          <div className={classes.container}>{children}</div>\n        </div>\n\n        {withIndicators && <div className={classes.indicators}>{indicators}</div>}\n\n        {withControls && (\n          <div className={classes.controls}>\n            <UnstyledButton\n              onClick={handlePrevious}\n              className={classes.control}\n              aria-label={previousControlLabel}\n              data-inactive={!canScrollPrev || undefined}\n              tabIndex={canScrollPrev ? 0 : -1}\n            >\n              {typeof previousControlIcon !== 'undefined' ? (\n                previousControlIcon\n              ) : (\n                <ChevronIcon\n                  style={{\n                    transform: `rotate(${getChevronRotation({\n                      dir: theme.dir,\n                      orientation,\n                      direction: 'previous',\n                    })}deg)`,\n                  }}\n                />\n              )}\n            </UnstyledButton>\n\n            <UnstyledButton\n              onClick={handleNext}\n              className={classes.control}\n              aria-label={nextControlLabel}\n              data-inactive={!canScrollNext || undefined}\n              tabIndex={canScrollNext ? 0 : -1}\n            >\n              {typeof nextControlIcon !== 'undefined' ? (\n                nextControlIcon\n              ) : (\n                <ChevronIcon\n                  style={{\n                    transform: `rotate(${getChevronRotation({\n                      dir: theme.dir,\n                      orientation,\n                      direction: 'next',\n                    })}deg)`,\n                  }}\n                />\n              )}\n            </UnstyledButton>\n          </div>\n        )}\n      </Box>\n    </CarouselProvider>\n  );\n}) as any;\n\n_Carousel.Slide = CarouselSlide;\n_Carousel.displayName = '@mantine/carousel/Carousel';\n\nexport const Carousel: ForwardRefWithStaticComponents<\n  CarouselProps,\n  { Slide: typeof CarouselSlide }\n> = _Carousel;\n", "import { useEffect } from 'react';\nimport { Embla } from './types';\n\nexport function useAnimationOffsetEffect(\n  embla: Embla | null | undefined,\n  transitionDuration: number\n) {\n  useEffect(() => {\n    if (embla) {\n      window.setTimeout(() => {\n        embla.reInit();\n      }, transitionDuration);\n    }\n  }, [embla, transitionDuration]);\n}\n"],
  "mappings": "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",
  "names": ["map", "value", "iStart", "iStop", "oStart", "oStop", "isNumber", "subject", "isObject", "Object", "prototype", "toString", "call", "isArray", "Array", "isRecord", "mathAbs", "n", "Math", "abs", "mathSign", "deltaAbs", "valueB", "valueA", "factorAbs", "diff", "roundToDecimals", "decimalPoints", "pow", "round", "arrayKeys", "array", "objectKeys", "Number", "arrayLast", "arrayLastIndex", "max", "length", "object", "keys", "objectsMergeDeep", "objectA", "objectB", "reduce", "mergedObjects", "currentObject", "forEach", "key", "areObjects", "objectsAreEqual", "objectAKeys", "objectBKeys", "every", "concat", "Alignment", "align", "viewSize", "predefined", "start", "center", "end", "percent", "measure", "self", "Animation", "callback", "animationFrame", "ifAnimating", "active", "cb", "window", "requestAnimationFrame", "stop", "cancelAnimationFrame", "proceed", "Axis", "axis", "direction", "scroll", "cross", "startEdge", "getStartEdge", "endEdge", "getEndEdge", "measureSize", "rect", "width", "height", "Limit", "min", "reachedMin", "reachedMax", "reachedAny", "constrain", "removeOffset", "ceil", "Counter", "loop", "_a", "loopEnd", "counter", "withinLimit", "get", "set", "add", "clone", "Direction", "sign", "apply", "EventStore", "listeners", "node", "type", "handler", "options", "addEventListener", "push", "removeEventListener", "removeAll", "filter", "remove", "Vector1D", "vector", "readNumber", "subtract", "multiply", "divide", "normalize", "DragHandler", "rootNode", "target", "dragTracker", "location", "animation", "scrollTo", "scrollBody", "scrollTarget", "index", "eventHandler", "percentOfView", "dragFree", "skipSnaps", "crossAxis", "focusNodes", "dragStartPoint", "activationEvents", "interactionEvents", "dragThreshold", "snapForceBoost", "mouse", "touch", "freeForceBoost", "baseSpeed", "baseMass", "startScroll", "startCross", "pointerIsDown", "preventScroll", "preventClick", "isMouse", "addActivationEvents", "undefined", "down", "up", "click", "addInteractionEvents", "document", "move", "removeAllEvents", "isFocusNode", "name", "nodeName", "indexOf", "forceBoost", "boost", "allowedForce", "force", "targetChanged", "next", "isEdge", "baseForce", "byDistance", "distance", "byIndex", "evt", "button", "isMoving", "clearPreventClick", "isNotFocusNode", "preventDefault", "pointerDown", "useBaseMass", "useSpeed", "readPoint", "emit", "cancelable", "lastScroll", "lastCross", "diffScroll", "diffCross", "pointerMove", "currentLocation", "rawForce", "pointerUp", "forceFactor", "isVigorous", "isBelowThreshold", "speed", "mass", "useMass", "clickAllowed", "DragTracker", "logInterval", "startEvent", "lastEvent", "isTouchEvent", "TouchEvent", "readTime", "timeStamp", "evtAxis", "property", "coord", "touches", "expired", "diffDrag", "diffTime", "isFlick", "PercentOfView", "ScrollBody", "roundToTwoDecimals", "velocity", "acceleration", "attraction", "attractionDirection", "update", "applyForce", "seek", "magnitude", "settle", "hasSettled", "useBaseSpeed", "ScrollBounds", "limit", "pullBackThreshold", "edgeOffsetTolerance", "maxFriction", "disabled", "shouldConstrain", "edge", "diffToEdge", "diffToTarget", "friction", "toggleActive", "ScrollContain", "contentSize", "snapsAligned", "containScroll", "scrollBounds", "snapsBounded", "snapsContained", "measureContained", "findDuplicates", "startSnap", "endSnap", "lastIndexOf", "slice", "ScrollLimit", "scrollSnaps", "measureLimit", "ScrollLooper", "vectors", "jointSafety", "shouldLoop", "loopDistance", "v", "ScrollProgress", "scrollLength", "ScrollSnaps", "alignment", "containerRect", "slideRects", "slideSizesWithGaps", "slidesToScroll", "groupSlides", "alignments", "measureSizes", "snaps", "measureUnaligned", "measureAligned", "rects", "snap", "containedStartSnap", "containedEndSnap", "g", "groupedSnaps", "isFirst", "isLast", "ScrollTarget", "targetVector", "minDistance", "distances", "sort", "a", "b", "findTargetSnap", "ascDiffsToSnaps", "scrollSnap", "diffToSnap", "shortcut", "i", "d1", "d2", "targets", "matchingTargets", "t", "targetSnapDistance", "reachedBound", "snapDistance", "ScrollTo", "indexCurrent", "indexPrevious", "distanceDiff", "indexDiff", "targetIndex", "Translate", "container", "translate", "x", "y", "containerStyle", "style", "to", "transform", "clear", "getAttribute", "removeAttribute", "SlideLooper", "slidesInView", "slides", "ascItems", "descItems", "reverse", "loopPoints", "startPoints", "endPoints", "removeSlideSizes", "indexes", "from", "slidesInGap", "gap", "remainingGap", "findLoopPoints", "isStartEdge", "offset", "slideBounds", "findSlideBounds", "initial", "altered", "bounds", "point", "shift", "canLoop", "otherIndexes", "loopPoint", "SlidesInView", "slideSizes", "inViewThreshold", "roundingSafety", "cachedOffsets", "cachedBounds", "findSlideThresholds", "threshold", "slideThreshold", "slideSize", "thresholdLimit", "offsets", "slideOffsets", "slideThresholds", "list", "check", "limitedLocation", "slideBound", "inList", "inView", "SlideSizes", "includeEdgeGap", "startGap", "measureStartGap", "endGap", "measureEndGap", "measureWithGaps", "slideRect", "getComputedStyle", "parseFloat", "getPropertyValue", "SlidesToScroll", "groupByNumber", "byNumber", "groupSize", "bySize", "groupSizes", "chunk", "chunkSize", "s", "Engine", "root", "scrollAxis", "contentDirection", "startIndex", "getBoundingClientRect", "slide", "containSnaps", "_b", "slideIndexes", "engine", "dragHandler", "settled", "scrollLooper", "slideLooper", "startLocation", "eventStore", "scrollProgress", "EventHandler", "getListeners", "e", "on", "off", "defaultOptions", "breakpoints", "draggable", "OptionsHandler", "merge", "optionsA", "optionsB", "areEqual", "breakpointsA", "JSON", "stringify", "breakpointsB", "atMedia", "optionsAtMedia", "matchedMediaOptions", "media", "matchMedia", "matches", "mediaOption", "PluginsHandler", "activePlugins", "pluginsChanged", "haveChanged", "some", "hasChanged", "plugin", "init", "plugins", "embla", "assign", "destroy", "EmblaCarousel", "nodes", "userOptions", "userPlugins", "resizeHandlers", "optionsHandler", "pluginsHandler", "reInit", "reActivate", "destroyed", "optionsBase", "globalOptions", "pluginList", "pluginApis", "rootSize", "storeElements", "providedContainer", "providedSlides", "children", "activate", "withOptions", "withPlugins", "deActivate", "offsetParent", "selectedScrollSnap", "resize", "newOptions", "optionsChanged", "newRootSize", "rootSizeChanged", "slidesNotInView", "jump", "scrollNext", "scrollPrev", "prev", "canScrollNext", "canScrollPrev", "scrollSnapList", "previousScrollSnap", "internalEngine", "containerNode", "slideNodes", "setTimeout", "canUseDOM", "window", "document", "createElement", "sortAndMapPluginToOptions", "plugins", "concat", "sort", "a", "b", "name", "map", "plugin", "options", "arePluginsEqual", "pluginsA", "pluginsB", "length", "areEqual", "EmblaCarousel", "optionsHandler", "optionsA", "optionsB", "every", "optionA", "index", "optionB", "useEmblaCarousel", "useRef", "storedOptions", "storedPlugins", "_a", "useState", "embla", "setEmbla", "_b", "viewport", "setViewport", "reInit", "useCallback", "current", "useEffect", "globalOptions", "newEmbla_1", "destroy", "undefined", "__defProp", "__getOwnPropSymbols", "__hasOwnProp", "__propIsEnum", "__defNormalProp", "__spreadValues", "React", "__defProp", "__getOwnPropSymbols", "__hasOwnProp", "__propIsEnum", "__defNormalProp", "__spreadValues", "useStyles", "__defProp", "__getOwnPropSymbols", "__hasOwnProp", "__propIsEnum", "__defNormalProp", "__spreadValues", "__objRest", "React"]
}
